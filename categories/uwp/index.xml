<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Uwp on Igor Kulman</title>
    <link>https://blog.davidmacias.com/categories/uwp/</link>
    <description>Recent content in Uwp on Igor Kulman</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <managingEditor>igor@kulman.sk (davidmacias)</managingEditor>
    <webMaster>igor@kulman.sk (davidmacias)</webMaster>
    <lastBuildDate>Tue, 28 Feb 2017 09:29:12 +0100</lastBuildDate>
    <atom:link href="/categories/uwp/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Creating a TV schedule grid in UWP</title>
      <link>https://blog.davidmacias.com/creating-a-tv-schedule-grid-in-uwp/</link>
      <pubDate>Tue, 28 Feb 2017 09:29:12 +0100</pubDate>
      <author>igor@kulman.sk (davidmacias)</author>
      <guid>https://blog.davidmacias.com/creating-a-tv-schedule-grid-in-uwp/</guid>
      <description>&lt;p&gt;I am currently working on a UWP app for a cable TV company. The app allows their clients to watch the TV channels they are subscribed to with additional information like the TV schedule, information about TV shows, recording TV shows for watching later, etc. One of the main functionalities of the app is a TV schedule grid. Creating this TV schedule grid in UWP is not so easy, especially because of the poor XAML rendering performance.&lt;/p&gt;

&lt;h2 id=&#34;tv-schedule-grid&#34;&gt;TV schedule grid&lt;/h2&gt;

&lt;p&gt;The TV schedule grid shows a TV schedule for all the subscribed channels for a given day. The channels are being shown in rows and the columns represent TV shows. The grid is scrollable in both directions and the channel logos are sticky. The users can be subscribed up 70 channels and all of this should work reasonably well even on a Windows Phone.&lt;/p&gt;

&lt;p&gt;This is how the result looks in a Windows Phone emulator. Spoiler: there is just no way to make it so smooth on a real Windows Phone device.&lt;/p&gt;

&lt;img src=&#34;https://blog.davidmacias.com/images/tvgrid.gif&#34; alt=&#34;&#34; class=&#34;pure-img&#34; &gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;xaml-controls&#34;&gt;XAML controls&lt;/h2&gt;

&lt;p&gt;My first and obvious approach to implement the TV schedule grid was to use native XAML controls. The &lt;code&gt;ScrollViewer&lt;/code&gt; control got a handy &lt;code&gt;LeftHeader&lt;/code&gt; property in UWP making implementing the sticky channels logos easy. The problem with &lt;code&gt;ScrollViewer&lt;/code&gt; is it does not support virtualization. If you create something like a huge &lt;code&gt;Grid&lt;/code&gt; with all the data and put into the &lt;code&gt;ScrollViewer&lt;/code&gt; the app will crash because of memory constrains.&lt;/p&gt;

&lt;p&gt;You can create a &lt;code&gt;ListView&lt;/code&gt; or &lt;code&gt;GridView&lt;/code&gt; and use it to display rows and put another one into each row to show columns. You will gain virtualization that works, your app will not crash because of memory but the scrolling performance will be abysmal. The users will notice the virtualization manifesting itself as appearing and disappearing rows and columns resulting in very poor user experience. When you have a vertical &lt;code&gt;ListView&lt;/code&gt; where each row represents a TV channel containing another horizontal &lt;code&gt;ListView&lt;/code&gt; with the TV shows, then you have to face another hard problem. When the user scrolls horizontally in a row, you need all the other rows to scroll to the same horizontal position so the TV schedule stays in sync. Try syncing horizontal &lt;code&gt;ListViews&lt;/code&gt; in a virtualized vertical &lt;code&gt;ListView&lt;/code&gt;, I dare you.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Update:&lt;/em&gt; When I was trying out this solution I tried phasing as suggested by Tim Heuer in the comments. Instead of seeing empty gaps in the TV schedule when scrolling, as the result of virtualization, I sometimes saw TV show borders instead. It was better but still not good enough, the perceived performance did not improve much. And there was still the hard problem of syncing the horizontal &lt;code&gt;ListViews&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;My last idea was to put a big &lt;code&gt;Canvas&lt;/code&gt; into the &lt;code&gt;ScrollViewer&lt;/code&gt; and render only what is currently in view. This is the way the Radaee PDF I use in another project does PDF rendering. You can add XAML controls to the &lt;code&gt;Canvas&lt;/code&gt;, remove them when they are not in view anymore. This is quite laborious and the resulting performance is still not very good.&lt;/p&gt;

&lt;p&gt;You can also use the &lt;code&gt;Canvas&lt;/code&gt; as a canvas and draw primitives instead of using XAML controls. It is not very comfortable, it is quite low level stuff. Thinking about using such a low level solution made me think of Win2D.&lt;/p&gt;

&lt;h2 id=&#34;win2d&#34;&gt;Win2D&lt;/h2&gt;

&lt;p&gt;Win2D is an easy-to-use Windows Runtime API for immediate mode 2D graphics rendering with GPU acceleration. It is available to C# and C++ developers writing Windows apps for Windows 8.1, Windows Phone 8.1 and Windows 10. It utilizes the power of Direct2D, and integrates seamlessly with XAML and CoreWindow. I have some experience with Win2D, I &lt;a href=&#34;https://blog.davidmacias.com/creating-a-simple-windows-10-game-with-win2d&#34;&gt;used it when creating my retro Sokoban game&lt;/a&gt;. So I gave it a try.&lt;/p&gt;

&lt;p&gt;Win2D is a really low level API. This means I had to do a lot of math to compute what is currently in view and where to render it. Rendering TV shows is also not easy, you have to render the cell using rectangles, lines, etc. At least Win2D makes drawing texts relatively easy.&lt;/p&gt;

&lt;p&gt;The next thing to solve was scrolling the Win2D canvas. Capturing gestures and mouse movements on a XAML control is not easy, so I came up with another solution. I put a transparent &lt;code&gt;ScrollViewer&lt;/code&gt; over the Win2D grid making the Win2D canvas redraw when the &lt;code&gt;ViewChanged&lt;/code&gt; event fires. The math in the rendering logic takes the &lt;code&gt;ScrollViewer&lt;/code&gt; scroll positions into account to correctly determine what is currently in view.&lt;/p&gt;

&lt;h3 id=&#34;performance-tuning&#34;&gt;Performance tuning&lt;/h3&gt;

&lt;p&gt;After a lot of work this solution worked, rendered what I wanted it to. The performance seemed good in a Windows Phone emulator but when I tried it on a real phone I was disappointed. The performance was still quite bad. I found out rendering the texts is the slowest part, so the idea was to cache the texts or even better the whole cells by TV show.&lt;/p&gt;

&lt;p&gt;Win2D supports &lt;a href=&#34;https://microsoft.github.io/Win2D/html/Offscreen.htm&#34;&gt;offscreen drawing&lt;/a&gt;. This means you can render something into a texture and the use the texture instead of drawing it again, making it ideal as a form of caching. When rendering the cell of a TV show for the first time, I do not render it directly to the Win2D canvas but instead into a texture. I then add the rendered texture into a in-memory dictionary and draw it to the Win2D canvas. When I need to render the TV show cell again (when the users scrolls the TV schedule grid and the TV show is in view) I just render the texture again. This means you render each show with its multiple texts just once.&lt;/p&gt;

&lt;p&gt;Solving cache invalidation is quite easy in this case, the texture becomes invalid only when the TV show it represents becomes active (meaning it is currently being broadcasted on a given channel making it gray) or inactive (black). Of course you cannot cache everything, only a certain number of textures, but it is easily solved by setting a limit on the number of cached textures.&lt;/p&gt;

&lt;p&gt;With this performance improvement the TV schedule grid became quite tolerable on a Lumia 950, but still slow on a Lumia 750. Sadly, there was nothing else I could do about it. I asked about it on Twitter and found another developer who implemented a TV schedule grid in his app. He also used Win2D but just omitted it from the phone version, because of performance.&lt;/p&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Creating something like a TV schedule grid in UWP with good performance is simply impossible using XAML controls. You can use Win2D to gain some performance but the result is still not exactly great on Windows Phones.&lt;/p&gt;

&lt;p&gt;Even Microsoft XAML apps suffer from poor rendering performance. Just take a look at the list in the Add or remove programs section of Windows 10 settings. This is how it behaves on ma quad-core i5, 16 GB RAM and GTX 660.&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;en&#34;&gt;&lt;p lang=&#34;en&#34; dir=&#34;ltr&#34;&gt;When clients tell you your &lt;a href=&#34;https://twitter.com/hashtag/uwp?src=hash&#34;&gt;#uwp&lt;/a&gt; app is slow and lists lag, just show them how Microsoft does it in &lt;a href=&#34;https://twitter.com/hashtag/Windows10?src=hash&#34;&gt;#Windows10&lt;/a&gt;. Nothing better you can do. &lt;a href=&#34;https://t.co/rnDWLFEHeb&#34;&gt;pic.twitter.com/rnDWLFEHeb&lt;/a&gt;&lt;/p&gt;&amp;mdash; Igor Kulman (@igorkulman) &lt;a href=&#34;https://twitter.com/igorkulman/status/818938357275328514&#34;&gt;January 10, 2017&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;If Microsoft cannot create a well-performing lists in XAML and UWP, you as a developer cannot do much better no matter how hard you try.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Creating a simple Windows 10 game with Win2D</title>
      <link>https://blog.davidmacias.com/creating-a-simple-windows-10-game-with-win2d/</link>
      <pubDate>Wed, 15 Jun 2016 09:29:12 +0100</pubDate>
      <author>igor@kulman.sk (davidmacias)</author>
      <guid>https://blog.davidmacias.com/creating-a-simple-windows-10-game-with-win2d/</guid>
      <description>&lt;p&gt;Some time ago while looking at some pixel art work I got an idea to create a retro pixel art game for Windows 10. The choice was obvious, &lt;a href=&#34;https://www.microsoft.com/store/apps/9nblggh4xdln&#34;&gt;Sokoban&lt;/a&gt;. I have a very special relationship with the Sokoban game. The Delpi version of Sokoban was the first game I ever created. I later ported it to all the platforms I played with, namely J2ME (for my Siemens S60 phone), Linux (using Kylix which was basically a Delphi for Linux), Windows Phone 7 and now &lt;a href=&#34;https://www.microsoft.com/store/apps/9nblggh4xdln&#34;&gt;Sokoban Pixel&lt;/a&gt; for the Universal Windows Platform.&lt;/p&gt;

&lt;img src=&#34;https://blog.davidmacias.com/images/sokoban-gameplay.gif&#34; alt=&#34;&#34; class=&#34;pure-img&#34; &gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Win2D&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;I did not want to learn &lt;a href=&#34;https://unity3d.com/&#34;&gt;Unity&lt;/a&gt; and I considered it quite a overkill for such a simple game. &lt;a href=&#34;http://www.monogame.net/&#34;&gt;Monogame&lt;/a&gt; seemed like an obvious choice, because my Sokoban for Windows Phone 7 was written in XNA. But Monogame requires too much ceremony to install and set up so I was not very eager to use it. I found &lt;a href=&#34;https://github.com/Microsoft/Win2D&#34;&gt;Win2D&lt;/a&gt;. Win2D is an easy-to-use Windows Runtime API for immediate mode 2D graphics rendering with GPU acceleration. It is available to C# and C++ developers writing Windows apps for Windows 8.1, Windows Phone 8.1 and Windows 10. It utilizes the power of Direct2D, and integrates seamlessly with XAML and CoreWindow. This means you can create a normal XAML application, create all your non-gameplay screens in XAML and use Win2D just for the actual gameplay.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Initial setup and loading resources&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;To get started with Win2D just install the &lt;code&gt;Win2D.uwp&lt;/code&gt; Nuget package and add a &lt;code&gt;CanvasControl&lt;/code&gt; to your app. That&amp;rsquo;s it, no more setup required.&lt;/p&gt;

&lt;p&gt;Before drawing any resources you need to first load them. This should be done in the &lt;code&gt;CreateResources&lt;/code&gt; event of the &lt;code&gt;CanvasControl&lt;/code&gt;. This method should not be async so if you need to load your resources asynchronously (as you always do) you need to use a trick with a separate method&lt;/p&gt;

&lt;div data-gist=&#34;39f73f5117a02c94fbe3b85ec57bb8a8&#34; data-file=&#34;load.cs&#34;&gt;&lt;/div&gt;

&lt;p&gt;The code snippet also shows how to load a simple image as a resources. You probably will not need to load anything other that images in a simple game.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Drawing the game&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;To make the &lt;code&gt;CanvasControl&lt;/code&gt; draw your game you need to hook up the &lt;code&gt;Draw&lt;/code&gt; event and put all you rendering logic there. There are basically just two things you will want to render, text and images&lt;/p&gt;

&lt;div data-gist=&#34;39f73f5117a02c94fbe3b85ec57bb8a8&#34; data-file=&#34;draw.cs&#34;&gt;&lt;/div&gt;

&lt;p&gt;Both methods have many overloads so it is up to you to choose the one that suits you best. There are also other methods for drawing primitives like likes or circles, take a look at the &lt;a href=&#34;http://microsoft.github.io/Win2D/html/Introduction.htm&#34;&gt;documentation&lt;/a&gt;. When creating a pixel art game, make use you use the &lt;code&gt;CanvasImageInterpolation.NearestNeighbor&lt;/code&gt; otherwise your images will look blurred if not on sufficient resolution.&lt;/p&gt;

&lt;p&gt;Depending on the type of your game, you may need to refresh the game canvas periodically or just as a reaction to the user input. In both cases, just call &lt;code&gt;Invalidate()&lt;/code&gt; on your &lt;code&gt;CanvasControl&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Handling user input&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;If you want to make you game great on Windows 10, you need to handle a few different input methods because Windows 10 runs on a variety of different devices.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Keyboard and controller&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;First you should handle input from the keyboard, so the game is comfortably playable on a notebook or desktop PC. To do this, you can just subscribe to the &lt;code&gt;KeyUp&lt;/code&gt; method of the current page or to the global &lt;code&gt;Window.Current.CoreWindow.KeyUp&lt;/code&gt; event. Both events give you a &lt;code&gt;VirtualKey&lt;/code&gt; that the user pressed and you just decide what to do.&lt;/p&gt;

&lt;p&gt;If you want to make your game playable on the XBox One or on the PC with a XBox One controller, you should handle the controller input. Handling the controller input is the same as handling the keyboard, you just check for different keys. The resulting code may look like this.&lt;/p&gt;

&lt;div data-gist=&#34;39f73f5117a02c94fbe3b85ec57bb8a8&#34; data-file=&#34;input.cs&#34;&gt;&lt;/div&gt;

&lt;p&gt;If you want to make your game run on XBox One and do not have an XBox One to test it, just get the XBox One controller, connect it to your PC with an USB cable and make sure the whole game is controllable and playable just with it, without the keyboard or mouse.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Touch devices&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Making your game playable on a phone or on a tablet is a bit tricky. There are no input devices usually attached, so you have to come up with your own. There are many ways to handle this. You can recognizes swipes on the device, or make the user tilt the device. But the solution I like the best is to render a simple d-pad in the right corner of the screen. This way the user can hold the device in both hands and use the right thumb to play the game.&lt;/p&gt;

&lt;img src=&#34;https://blog.davidmacias.com/images/sokoban-dpad.png&#34; alt=&#34;&#34; class=&#34;pure-img&#34; &gt;

&lt;p&gt;&lt;strong&gt;Conclusion&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;When building a simple 2D game for Windows 10, making it a UWP app and use Win2D. The Win2D framework is easy to work with and embed into UWP apps.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Creating better forms in Windows Phone apps</title>
      <link>https://blog.davidmacias.com/creating-better-forms-in-windows-phone-apps/</link>
      <pubDate>Tue, 29 Mar 2016 09:29:12 +0100</pubDate>
      <author>igor@kulman.sk (davidmacias)</author>
      <guid>https://blog.davidmacias.com/creating-better-forms-in-windows-phone-apps/</guid>
      <description>&lt;p&gt;If you are a Windows Phone user you must know that filling in forms in apps is usually a real pain. There is no good way to move from one input to another or to collapse the keyboard. The whole process becomes a struggle, tapping outside the input fields to collapse the keyboard allowing you to scroll to the next input or to the submit button at the top of the screen, usually occluded by the keyboard.&lt;/p&gt;

&lt;p&gt;The typical struggle to get to the last input fields and the submit button may look like this&lt;/p&gt;

&lt;img src=&#34;https://blog.davidmacias.com/images/forms1.gif&#34; alt=&#34;&#34; class=&#34;pure-img&#34; &gt;

&lt;p&gt;There is no guidance on how to approach this. Take a look at the Store app on Windows 10 mobile, the perfect example of bad UI and UX directly from Microsoft and try review an app. You fill in the title of the review, then struggle to go into the review text input, you have to tap somewhere above the input to hide the keyboard, but not to hit the stars control &amp;hellip; just an UX disaster.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;There is one simple thing you can do to make the experience much better for the user. When the keyboard appears on the screen, take the area of the screen than contains the input and add it a bottom margin corresponding to the height of the keyboard. This will make the whole screen longer and all the inputs and the submit button will be available while scrolling without the need to hide the keyboard.&lt;/p&gt;

&lt;p&gt;The whole experience becomes much better&lt;/p&gt;

&lt;img src=&#34;https://blog.davidmacias.com/images/forms2.gif&#34; alt=&#34;&#34; class=&#34;pure-img&#34; &gt;

&lt;p&gt;Implementation is also simple.&lt;/p&gt;

&lt;script src=&#34;https://gist.github.com/igorkulman/250de623e9213bc3bf90.js&#34;&gt;&lt;/script&gt;</description>
    </item>
    
    <item>
      <title>Using Tooltips to make better menus in Windows apps</title>
      <link>https://blog.davidmacias.com/using-tooltips-to-make-better-menus-in-windows-apps/</link>
      <pubDate>Wed, 23 Mar 2016 09:29:12 +0100</pubDate>
      <author>igor@kulman.sk (davidmacias)</author>
      <guid>https://blog.davidmacias.com/using-tooltips-to-make-better-menus-in-windows-apps/</guid>
      <description>&lt;p&gt;If you use Windows apps with navigation menus consisting of icons, you may have noticed that some of those apps show you a text when hovering above those icons. This is a nice touch for the users, allowing them to quickly grasp the meaning of the menu icons without the need to click them or to expand the menu (if available).&lt;/p&gt;

&lt;img src=&#34;https://blog.davidmacias.com/images/tooltips.gif&#34; alt=&#34;&#34; class=&#34;pure-img&#34; &gt;

&lt;p&gt;Implementing this kind of hovers is really easy thanks to the &lt;code&gt;ToolTipService&lt;/code&gt; that is available in Windows 8.1 and Windows 10 UWP. You can add &lt;code&gt;&amp;lt;ToolTipService.ToolTip&amp;gt;&lt;/code&gt; with any element and include basically any XAML content as the tooltip. Here is a sample from the animation using a simple localized &lt;code&gt;TextBlock&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;script src=&#34;https://gist.github.com/igorkulman/c7320d81f9b882bcfd69.js&#34;&gt;&lt;/script&gt;</description>
    </item>
    
    <item>
      <title>Choosing an image from gallery or camera a bit better in Universal Windows apps</title>
      <link>https://blog.davidmacias.com/choosing-an-image-from-gallery-or-camera-in-uwp/</link>
      <pubDate>Mon, 14 Mar 2016 09:29:12 +0100</pubDate>
      <author>igor@kulman.sk (davidmacias)</author>
      <guid>https://blog.davidmacias.com/choosing-an-image-from-gallery-or-camera-in-uwp/</guid>
      <description>&lt;p&gt;When developing Windows Phone apps you may encounter a use case when you have to allow the user to either pick a photo from the photos gallery in the photo or a take a new photo using the phone&amp;rsquo;s camera. One example of this may be the registration process when the user may choose a profile picture.&lt;/p&gt;

&lt;p&gt;In Windows Phone 8.1, this task is quite simple, just use the &lt;code&gt;FileOpenPicker&lt;/code&gt;. It allows you to pick a photo from the gallery or take a new photo. Just take a look at this animation showing how the users takes a new photo using the phone&amp;rsquo;s camera.&lt;/p&gt;

&lt;img src=&#34;https://blog.davidmacias.com/images/wpa81.gif&#34; alt=&#34;&#34; class=&#34;pure-img&#34; &gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;The code for this is relatively simple, although the &lt;code&gt;AndContinue&lt;/code&gt; pattern can be a pain&lt;/p&gt;

&lt;script src=&#34;https://gist.github.com/igorkulman/2885b4a6faa5b0861f17.js?file=pick-wpa81.cs&#34;&gt;&lt;/script&gt;

&lt;p&gt;In Windows 10 Mobile, the &lt;code&gt;FileOpenPicker&lt;/code&gt; has been changed to be more customizable. This make the process of  taking a new photo using the phone&amp;rsquo;s camera totally hidden. Not a chance a common user will discover it, just take a look at this animation.&lt;/p&gt;

&lt;img src=&#34;https://blog.davidmacias.com/images/uwp.gif&#34; alt=&#34;&#34; class=&#34;pure-img&#34; &gt;

&lt;p&gt;So how to make this experience a bit better for the user? My solution is instead of launching the &lt;code&gt;FileOpenPicker&lt;/code&gt; showing a &lt;code&gt;Flyout&lt;/code&gt; with two options; Choose from gallery and Take photo. The Choose from gallery option just launches the &lt;code&gt;FileOpenPicker&lt;/code&gt;&lt;/p&gt;

&lt;script src=&#34;https://gist.github.com/igorkulman/2885b4a6faa5b0861f17.js?file=pick-uwp.cs&#34;&gt;&lt;/script&gt;

&lt;p&gt;and the Take photo option uses CameraCaptureUI to directly take a photo&lt;/p&gt;

&lt;script src=&#34;https://gist.github.com/igorkulman/2885b4a6faa5b0861f17.js?file=camera-uwp.cs&#34;&gt;&lt;/script&gt;       

&lt;p&gt;The result might look like this. Do not forget to add an option to delete the photo if one is already chosen.&lt;/p&gt;

&lt;img src=&#34;https://blog.davidmacias.com/images/uwp2.gif&#34; alt=&#34;&#34; class=&#34;pure-img&#34; &gt;</description>
    </item>
    
    <item>
      <title>Mobilize.net: Converting Windows Phone 8 apps to UWP? Not really</title>
      <link>https://blog.davidmacias.com/mobilize-net-converting-windows-phone-apps-to-uwp/</link>
      <pubDate>Fri, 18 Dec 2015 09:29:12 +0100</pubDate>
      <author>igor@kulman.sk (davidmacias)</author>
      <guid>https://blog.davidmacias.com/mobilize-net-converting-windows-phone-apps-to-uwp/</guid>
      <description>&lt;p&gt;When Microsoft announced the Windows 10 developer platform, they also announced bridges to make porting apps from Android, iOS and Web easier. Those bridges are now either dead (Android) or unusable (iOS) but there is another tool that can be considered a bridge left. It is called &lt;a href=&#34;http://www.mobilize.net/download-silverlight-bridge&#34;&gt;Mobilize.net Silverlight&lt;/a&gt; Bridge and it is not from Microsoft. It promises converting existing Windows Phone 8 (Silverlight apps) to the Universal Windows Platform. Considering the majority of apps in the Windows Phone Store are Windows Phone 8 apps and the fact that Android and iOS developers do not really care about Windows, Mobilize.net seem to be the most useful of the bridges, because there is no easy porting apps from Windows Phone 8 to UWP, just rewriting. So I tried it out.&lt;/p&gt;

&lt;img src=&#34;https://blog.davidmacias.com/images/Windows10-Devices.png?t=1449725816496&amp;amp;width=425&amp;amp;height=210&#34; alt=&#34;&#34; class=&#34;pure-img&#34; &gt;

&lt;p&gt;Mobilize.net is currently in technical preview. After you download and install it, it integrates into Visual Studio 2015 and there is a new context menu for Windows Phone 8 project, allowing you to convert them to UWP apps. If you use it, you get a dialog windows and a conversion process that will fail most of the times with a strange error. At least for me it did.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;I got in touch with their support and I found out the reason for the conversion always failing. They do not support C# 6 all and mine, and probably all yours, project use C# 6. If you look at the error logs a bit closer, you will see error messages about failed tokenization. This is really strange, it looks like they are parsing the source code as text, instead of just using Roslyn. I do not get why, but they probably have a reason for this.&lt;/p&gt;

&lt;p&gt;If you go through all the trouble and remove all the C# 6 features from your project, the conversion will succeed. You will get a UWP project, that will most likely not compile. There are two main reasons for this.&lt;/p&gt;

&lt;p&gt;Mobilize.net changes your XAML to fix namespaces and replace controls that changed since Windows Phone 8, but it does not fix XAML features that were not available in UWP. And there are quite a few of them, from StringFormat in bindings to OpacityMask on images. You will have to fix your XAML manually and while you are at this, you will also have to rewrite your XAML to accommodate for the fact that there is not just one fixed resolution like it was in Windows Phone 8. Your XAML has to be responsive now. Mobilize.net did not really help here.&lt;/p&gt;

&lt;p&gt;The seconds problem are third party libraries. There are &lt;a href=&#34;https://github.com/MobilizeNet/UWPConversionMappings&#34;&gt;some mappings available for popular third party libraries&lt;/a&gt;. This mapping do two things. First they make sure the UWP project uses the correct Nuget packages and then they map namespaces, both in XAML and C#, that changed when the third party library transitioned from Windows Phone 8 to UWP. Chances are that there are no UWP versions of some or even the majority of the third party libraries you use. Probably because the functionality is nor longer available all the API has completely changed.&lt;/p&gt;

&lt;p&gt;I reached out to the Mobilize.net support asking about these two things, but I never got an answer.&lt;/p&gt;

&lt;p&gt;In conclusion, if your app is not trivial, you use C# 6, third party libraries and all the available XAML features, your experience will not be very good. If you app is well written (MVVM, abstractions) your are better with creating a new UWP project, pasting your code and rewriting your XAML. If your app is more trivial, Mobilize.net will probably work well for you. But in this case, rewriting your app to UWP without it would be probably takes the same amount of time.&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>